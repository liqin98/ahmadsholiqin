{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Home/","text":"Nama : Ahmad Soliqin Nim : 180411100147 Prodi : Teknik Informatika","title":"Home"},{"location":"Numerical%20Solution/","text":"Numerical Solution of Algebraic and Transcendental Equation \u00b6 Sistem persaman aljabar dapat diuraikan seperti dibawah ini Persamaan transcendental : sin, cos, tan, Persamaan polynomial : a0 + a1x + a2x2 \u2026\u2026. + anxn + \u2026\u2026 Penyelesaian persamaan non linier \u00b6 Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant. method Bisection Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan langkah langkah Tentukan batas bawah (a) dan batas atas (b). Kemudian dihitung nilai tengah : $$ c = {(a+b)\\over 2} $$ Dari nilai c ini perlu dilakukan pengecekan keberadaan akar. Secara matematik, suatu range terdapat akar persamaan bila f(a) dan f(b) berlawanan tanda atau dituliskan : $$ f(a).f(b) <0 $$ Setelah diketahui di bagian mana terdapat akar, maka batas bawah dan batas atas diperbarui sesuai dengan range dari bagian yang mempunyai akar algoritma metode bisection 1.Definisikan fungsi f(x) yang akan dicari akarnya 2.Tentukan nilai a dan b 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung f(a) dan f(b) 5.Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan 6.Hitung x = (a+b)/2 7.Hitung f(x) 8.Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) 9.Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 implementasi metode bisection dalam python \u00b6 def bisection ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Bisection method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = ( a_n + b_n ) / 2 f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Bisection method fails.\" ) return None return ( a_n + b_n ) / 2 f = lambda x : x ** 2 - 5 * x + 6 approx_phi = bisection ( f , 1 , 2.3 , 25 ) print ( approx_phi ) 1.9999999985098835 methot Regula Falsi 1.Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. 2.Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. 3.Dikenal dengan metode False Position 4.Metode ini juga merupakan penyempurna dari metode bisection algoritma method regula falsi Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : $$ c= {(f(b).a -f(a).b)\\over (f(b)-f(a))} $$ Hitung f(c)=f(x) \u200b Hitung error = |f(c)| \u200b Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) Akar persamaanya = c implementasi method regula falsi dalam python \u00b6 error = 0.01 a = 0 b = 2.1 def f ( x ): return x ** 2 - 5 * x + 6 def regulasi_falsi ( a , b ): i = 0 max_iter = 50 iteration = True while iteration and i < max_iter : if f ( a ) * f ( b ) < 0 : x = ( a * abs ( f ( b )) + b * abs ( f ( a ))) / ( abs ( f ( a )) + abs ( f ( b ))) if f ( a ) * f ( x ) < 0 : b = x if f ( x ) * f ( b ) < 0 : a = x if abs ( a - b ) < error : iteration = False else : i += 1 else : print ( 'tidak di temukan akar' ) print ( 'x =' , x ) regulasi_falsi ( a , b ) x = 2.000000000174259 Metode Newton Raphson Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Prinsip Metode Newton Raphson Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. prosedur Menentukan x0 sebagai titik awal. Menarik garis lurus (misal garis P) yang menyinggung titik f(x0). Hal ini berakibat garis P memotong sumbu-x di titik x1. Ulangi langkah sebelumnya tapi sekarang x1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x1,x2,x3,...,,xn dengan xn yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya algoritma implementasi Metode Newton Raphson python \u00b6 def newton ( f , Df , x0 , epsilon , max_iter ): xn = x0 for n in range ( 0 , max_iter ): fxn = f ( xn ) if abs ( fxn ) < epsilon : print ( 'Found solution after' , n , 'iterations.' ) return xn Dfxn = Df ( xn ) if Dfxn == 0 : print ( 'Zero derivative. No solution found.' ) return None xn = xn - fxn / Dfxn print ( 'Exceeded maximum iterations. No solution found.' ) return None p = lambda x : x ** 2 - 5 * x + 6 Dp = lambda x : 2 * x - 5 approx = newton ( p , Dp , 1 , 1e-3 , 10 ) print ( approx ) Found solution after 4 iterations . 1.9999847409781035 Metode Secant \u25a0Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). \u25a0Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. \u25a0Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen \u25a0Modifikasi metode Newton Raphson dinamakan metode Secant. formula secant \u00b6 $$ y = \\frac{f(b) - f(a)}{b - a}(x - a) + f(a) $$ $$ 0 = \\frac{f(b) - f(a)}{b - a}(x - a) + f(a) $$ $$ x = a - f(a)\\frac{b - a}{f(b) - f(a)} $$ algoritma method secant \u00b6 \u25a0 Definisikan f(x) \u25a0 Definisikan toleransi error e dan iterasi maksimum (n) \u25a0 Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. \u25a0 Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 \u25a0 Untuk iterasi 1 s/d n x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) Akar persamaan adalah nilai x yang terakhir implementasi method secant pada python \u00b6 def secant ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Secant method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Secant method fails.\" ) return None return a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) p = lambda x : x ** 2 - 5 * x + 6 approx = secant ( p , 1 , 2.4 , 20 ) print ( approx ) 2.0000003178913373 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"Nurerical Solution"},{"location":"Numerical%20Solution/#numerical-solution-of-algebraic-and-transcendental-equation","text":"Sistem persaman aljabar dapat diuraikan seperti dibawah ini Persamaan transcendental : sin, cos, tan, Persamaan polynomial : a0 + a1x + a2x2 \u2026\u2026. + anxn + \u2026\u2026","title":"Numerical Solution of Algebraic and Transcendental Equation"},{"location":"Numerical%20Solution/#penyelesaian-persamaan-non-linier","text":"Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant. method Bisection Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan langkah langkah Tentukan batas bawah (a) dan batas atas (b). Kemudian dihitung nilai tengah : $$ c = {(a+b)\\over 2} $$ Dari nilai c ini perlu dilakukan pengecekan keberadaan akar. Secara matematik, suatu range terdapat akar persamaan bila f(a) dan f(b) berlawanan tanda atau dituliskan : $$ f(a).f(b) <0 $$ Setelah diketahui di bagian mana terdapat akar, maka batas bawah dan batas atas diperbarui sesuai dengan range dari bagian yang mempunyai akar algoritma metode bisection 1.Definisikan fungsi f(x) yang akan dicari akarnya 2.Tentukan nilai a dan b 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung f(a) dan f(b) 5.Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan 6.Hitung x = (a+b)/2 7.Hitung f(x) 8.Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) 9.Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6","title":"Penyelesaian persamaan non linier"},{"location":"Numerical%20Solution/#implementasi-metode-bisection-dalam-python","text":"def bisection ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Bisection method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = ( a_n + b_n ) / 2 f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Bisection method fails.\" ) return None return ( a_n + b_n ) / 2 f = lambda x : x ** 2 - 5 * x + 6 approx_phi = bisection ( f , 1 , 2.3 , 25 ) print ( approx_phi ) 1.9999999985098835 methot Regula Falsi 1.Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. 2.Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. 3.Dikenal dengan metode False Position 4.Metode ini juga merupakan penyempurna dari metode bisection algoritma method regula falsi Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : $$ c= {(f(b).a -f(a).b)\\over (f(b)-f(a))} $$ Hitung f(c)=f(x) \u200b Hitung error = |f(c)| \u200b Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) Akar persamaanya = c","title":"implementasi metode bisection dalam python"},{"location":"Numerical%20Solution/#implementasi-method-regula-falsi-dalam-python","text":"error = 0.01 a = 0 b = 2.1 def f ( x ): return x ** 2 - 5 * x + 6 def regulasi_falsi ( a , b ): i = 0 max_iter = 50 iteration = True while iteration and i < max_iter : if f ( a ) * f ( b ) < 0 : x = ( a * abs ( f ( b )) + b * abs ( f ( a ))) / ( abs ( f ( a )) + abs ( f ( b ))) if f ( a ) * f ( x ) < 0 : b = x if f ( x ) * f ( b ) < 0 : a = x if abs ( a - b ) < error : iteration = False else : i += 1 else : print ( 'tidak di temukan akar' ) print ( 'x =' , x ) regulasi_falsi ( a , b ) x = 2.000000000174259 Metode Newton Raphson Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Prinsip Metode Newton Raphson Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. prosedur Menentukan x0 sebagai titik awal. Menarik garis lurus (misal garis P) yang menyinggung titik f(x0). Hal ini berakibat garis P memotong sumbu-x di titik x1. Ulangi langkah sebelumnya tapi sekarang x1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x1,x2,x3,...,,xn dengan xn yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya algoritma","title":"implementasi method regula falsi dalam python"},{"location":"Numerical%20Solution/#implementasi-metode-newton-raphson-python","text":"def newton ( f , Df , x0 , epsilon , max_iter ): xn = x0 for n in range ( 0 , max_iter ): fxn = f ( xn ) if abs ( fxn ) < epsilon : print ( 'Found solution after' , n , 'iterations.' ) return xn Dfxn = Df ( xn ) if Dfxn == 0 : print ( 'Zero derivative. No solution found.' ) return None xn = xn - fxn / Dfxn print ( 'Exceeded maximum iterations. No solution found.' ) return None p = lambda x : x ** 2 - 5 * x + 6 Dp = lambda x : 2 * x - 5 approx = newton ( p , Dp , 1 , 1e-3 , 10 ) print ( approx ) Found solution after 4 iterations . 1.9999847409781035 Metode Secant \u25a0Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). \u25a0Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. \u25a0Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen \u25a0Modifikasi metode Newton Raphson dinamakan metode Secant.","title":"implementasi Metode Newton Raphson python"},{"location":"Numerical%20Solution/#formula-secant","text":"$$ y = \\frac{f(b) - f(a)}{b - a}(x - a) + f(a) $$ $$ 0 = \\frac{f(b) - f(a)}{b - a}(x - a) + f(a) $$ $$ x = a - f(a)\\frac{b - a}{f(b) - f(a)} $$","title":"formula secant"},{"location":"Numerical%20Solution/#algoritma-method-secant","text":"\u25a0 Definisikan f(x) \u25a0 Definisikan toleransi error e dan iterasi maksimum (n) \u25a0 Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. \u25a0 Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 \u25a0 Untuk iterasi 1 s/d n x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) Akar persamaan adalah nilai x yang terakhir","title":"algoritma method secant"},{"location":"Numerical%20Solution/#implementasi-method-secant-pada-python","text":"def secant ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Secant method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Secant method fails.\" ) return None return a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) p = lambda x : x ** 2 - 5 * x + 6 approx = secant ( p , 1 , 2.4 , 20 ) print ( approx ) 2.0000003178913373 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"implementasi method secant pada python"},{"location":"tugas1/","text":"Selamat datang di halaman tugas komputasi numerik \u00b6 DEFINISI MACLAURIN \u00b6 Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret TaylorDefinisi. Berikut algoritma dari maclaurin \u00b6 Dengan algoritma diatas kita dapat menyerderhanakannya sebagai berikut: berikut contoh implementai dari maclaurin f(x)= e 2x $$ f(x)\u22481+2x \\displaystyle+\\frac{{{{f}^{{\\text{}}}{\\left({2x^2}\\right)}}}}{{{3}!}} \\displaystyle+\\frac{{{{f}^{{\\text{}}}{\\left({2x^3}\\right)}}}}{{{3}!}} \\displaystyle+\\ldots+\u2026 $$ sekarang kita masukan misal x=0 $$ f(0)\u22481+2(0) \\displaystyle+\\frac{{{{}^{{\\text{}}}{\\left({2(0)^2}\\right)}}}}{{{3}!}} \\displaystyle+\\frac{{{{}^{{\\text{}}}{\\left({2(0)^3}\\right)}}}}{{{3}!}} \\displaystyle+\\ldots+\u2026 $$ jadi ketika x =0 maka hasil akan tetap 1 mekipun banyak suku dan literasi Listing Program \u00b6 membuat program supaya dapaat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dengan listing program sebagai berikut. import math x = 4 coba = 1 a = 0 b = 1 while coba > 0.001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += ( 2 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += ( 2 ** j ) * x ** j / math . factorial ( j ) coba = f_y - f_x a += 1 b += 1 print ( coba ) output: 1.0 8.0 32.0 85.33333333333333 170.66666666666669 273.0666666666666 364.08888888888896 416.1015873015872 416.1015873015872 369.8680776014112 295.89446208112895 215.195972422639 143.46398161509296 88.28552714774924 50.448872655856576 26.90606541645684 13.45303270822842 6.330838921519444 2.8137061873417224 1.184718394670199 0.47388735786807956 0.18052851728316455 0.06564673355751438 0.022833646454728296 0.0076112154847578495 0.0024355889549951826 0.0007494119863622473 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"Error"},{"location":"tugas1/#selamat-datang-di-halaman-tugas-komputasi-numerik","text":"","title":"Selamat datang di halaman tugas komputasi numerik"},{"location":"tugas1/#definisi-maclaurin","text":"Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret TaylorDefinisi.","title":"DEFINISI MACLAURIN"},{"location":"tugas1/#berikut-algoritma-dari-maclaurin","text":"Dengan algoritma diatas kita dapat menyerderhanakannya sebagai berikut: berikut contoh implementai dari maclaurin f(x)= e 2x $$ f(x)\u22481+2x \\displaystyle+\\frac{{{{f}^{{\\text{}}}{\\left({2x^2}\\right)}}}}{{{3}!}} \\displaystyle+\\frac{{{{f}^{{\\text{}}}{\\left({2x^3}\\right)}}}}{{{3}!}} \\displaystyle+\\ldots+\u2026 $$ sekarang kita masukan misal x=0 $$ f(0)\u22481+2(0) \\displaystyle+\\frac{{{{}^{{\\text{}}}{\\left({2(0)^2}\\right)}}}}{{{3}!}} \\displaystyle+\\frac{{{{}^{{\\text{}}}{\\left({2(0)^3}\\right)}}}}{{{3}!}} \\displaystyle+\\ldots+\u2026 $$ jadi ketika x =0 maka hasil akan tetap 1 mekipun banyak suku dan literasi","title":"Berikut algoritma dari maclaurin"},{"location":"tugas1/#listing-program","text":"membuat program supaya dapaat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dengan listing program sebagai berikut. import math x = 4 coba = 1 a = 0 b = 1 while coba > 0.001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += ( 2 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += ( 2 ** j ) * x ** j / math . factorial ( j ) coba = f_y - f_x a += 1 b += 1 print ( coba ) output: 1.0 8.0 32.0 85.33333333333333 170.66666666666669 273.0666666666666 364.08888888888896 416.1015873015872 416.1015873015872 369.8680776014112 295.89446208112895 215.195972422639 143.46398161509296 88.28552714774924 50.448872655856576 26.90606541645684 13.45303270822842 6.330838921519444 2.8137061873417224 1.184718394670199 0.47388735786807956 0.18052851728316455 0.06564673355751438 0.022833646454728296 0.0076112154847578495 0.0024355889549951826 0.0007494119863622473 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"Listing Program"}]}